###BIO
>传统的bio编程模型，一般情况下都是通过主线程来监听客户端的连接，一般情况下都是通过while(ture)
>死循环来监听客户端的连接accept()。如果这个时候没有客户端连接进来，那么这个accept()这个方法
>就一直阻塞在这里。当有客户端连接进来之后，服务端会启动一个线程和客户端进行连接，通过socket.read()
>方法读取客户端的数据。如果客户端没有数据上来的话，那么这个线程就会一直阻塞在read方法直到接到数据。
###BIO缺点
1. 每个客户端连接/请求，服务端都需要一个线程和客户端进行对应
2. 当并发量很大的情况下，需要创建很多的线程进行链接，占用大量的系统资源
3. 当连接建立之后，如果没有数据的读操作，线程也不会释放，阻塞在read方法上，造成大量资源的
浪费


当出现了很多没用的线程的时候，需要通过时钟的中断进行用户态和内核态的切换。这种切换本身就存在的没意义，需要线程的
启动，恢复等操作，但是又没有得到数据。所以就导致系统资源的浪费，一直进行中断，其他资源都用不了。

bio的问题在于不断的产生线程，在accept阶段和read阶段都一直在堵塞。这个堵塞主要体现在底层上，所以
如果要从根本上解决这个堵塞问题，就需要在底层上进行处理。
使用strace 可以进行查看用户态调用内核态的过程。

命令操作如下：

javac SocketBIO.java
strace -ff -o out java SocketBIO
